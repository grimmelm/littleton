open Common
open Event

(* AM: mostly autogenerated mli *)

type timing_t = Defer | Close
val timing_t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> timing_t
val sexp_of_timing_t : timing_t -> Ppx_sexp_conv_lib.Sexp.t
module ClassGifts :
  sig
    module B = Branch
    module D = Description
    module F = Family
    module H = Holder
    module P = Person
    module E = Event
    val frac : int -> int -> int * int
    val sole : 'a -> ('a * (int * int)) list
    val holder_of_p : P.t -> H.t
    val holderize : P.t list -> H.t list
    val holderize_shares : (P.t * 'a) list -> (H.t * 'a) list
    val equal_shares : 'a list -> ('a * (int * int)) list
    val split_among : P.t list -> (H.t * (int * int)) list
    val scale :
      int -> ('a, int) Base.List.Assoc.t -> ('a, int) Base.List.Assoc.t
    val by_primogeniture : P.t -> E.t list -> (P.t * (int * int)) list
    val per_capita : P.t -> E.t list -> (P.t * (int * int)) list
    val per_stirpes : P.t -> E.t list -> (P.t * (int * int)) list
    val by_representation : P.t -> E.t list -> (P.t * (int * int)) list
    val descendants : P.t -> B.t -> E.t list -> H.t Common.shares
    val intestate_heirs : P.t -> E.t list -> H.t Common.shares
    val filter_by_restriction : D.restriction -> E.t list -> H.t * 'a -> bool
    val filter_by_always : D.restriction -> E.t list -> H.t * 'a -> bool
    val eval : D.t -> E.t list -> H.t Common.shares
    val always : D.t -> E.t list -> H.t Common.shares
    val track_base : D.t -> E.t list -> H.t Common.shares
    val track : D.t -> E.t list -> (H.t * Common.Q.t) list
    val closed : D.t -> E.t list -> bool
    val empty : D.t -> E.t list -> bool
    val possibly_fail_ascertain : D.t -> E.t list -> bool
    val possibly_remote_ascertain : D.t -> E.t list -> bool
  end
