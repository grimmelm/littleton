
(* AM: mostly autogenerated mli *)

module Interval :
  sig
    type t = int
    val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t
    val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t
    val to_string : t -> string
  end
type interval = int
val interval_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> interval
val sexp_of_interval : interval -> Ppx_sexp_conv_lib.Sexp.t
module Event :
  sig
    type t =
        Empty
      | Dies of Common.person
      | ConveysAway of Common.person
      | Marry of Common.person * Common.person option
      | Divorce of Common.person * Common.person option
      | Child of Common.person * Common.person
      | Graduates of Common.person * string
      | BecomesState of string
      | Consumes of Common.person * string
      | IsUsedAs of string
      | FailureOfIssue of Common.person
      | YearsPass of interval
      | Reenters of Common.person
      | Start
      | Generic of string
    val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t
    val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t
    val possibly_remote : t -> bool
    val to_string : t -> string
    val ( = ) : t -> t -> bool
    val all_possibilities : (string * interval) list
    val json_of_list :
      ('a * 'b) list ->
      [> `Assoc of (string * [> `Int of 'b | `String of 'a ]) list ] list
    val possibility_of_string :
      string ->
      [> `List of
           [> `Assoc of
                (string * [> `Int of interval | `String of string ]) list ]
           list ]
    val possibilities :
      t ->
      [> `List of
           [> `Assoc of
                (string * [> `Int of interval | `String of string ]) list ]
           list ]
    val get_person : t -> Common.person list
  end
type event = Event.t
val event_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> event
val sexp_of_event : event -> Ppx_sexp_conv_lib.Sexp.t
type history = event list
val history_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> history
val sexp_of_history : history -> Ppx_sexp_conv_lib.Sexp.t
module EventSet :
  sig
    module E = Event
    module M :
      sig
        module Elt :
          sig
            type t = event
            val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t
            val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t
            type comparator_witness
            val comparator :
              (t, comparator_witness) Core_kernel.Comparator.comparator
          end
        module Tree :
          sig
            type t =
                (event, Elt.comparator_witness) Core_kernel.Set_intf.Tree.t
            val compare : t -> t -> interval
            type named =
                (event, Elt.comparator_witness)
                Core_kernel.Set_intf.Tree.Named.t
            val length : t -> interval
            val is_empty : t -> bool
            val iter : t -> f:(event -> unit) -> unit
            val fold :
              t -> init:'accum -> f:('accum -> event -> 'accum) -> 'accum
            val fold_result :
              t ->
              init:'accum ->
              f:('accum -> event -> ('accum, 'e) Base.Result.t) ->
              ('accum, 'e) Base.Result.t
            val exists : t -> f:(event -> bool) -> bool
            val for_all : t -> f:(event -> bool) -> bool
            val count : t -> f:(event -> bool) -> interval
            val sum :
              (module Base__Container_intf.Summable with type t = 'sum) ->
              t -> f:(event -> 'sum) -> 'sum
            val find : t -> f:(event -> bool) -> event option
            val find_map : t -> f:(event -> 'a option) -> 'a option
            val to_list : t -> event list
            val to_array : t -> event array
            val invariants : t -> bool
            val mem : t -> event -> bool
            val add : t -> event -> t
            val remove : t -> event -> t
            val union : t -> t -> t
            val inter : t -> t -> t
            val diff : t -> t -> t
            val symmetric_diff :
              t -> t -> (event, event) Base.Either.t Base.Sequence.t
            val compare_direct : t -> t -> interval
            val equal : t -> t -> bool
            val is_subset : t -> of_:t -> bool
            val are_disjoint : t -> t -> bool
            module Named :
              sig
                val is_subset : named -> of_:named -> unit Base.Or_error.t
                val equal : named -> named -> unit Base.Or_error.t
              end
            val fold_until :
              t ->
              init:'b ->
              f:('b ->
                 event -> ('b, 'final) Base__Set_intf.Continue_or_stop.t) ->
              finish:('b -> 'final) -> 'final
            val fold_right : t -> init:'b -> f:(event -> 'b -> 'b) -> 'b
            val iter2 :
              t ->
              t ->
              f:([ `Both of event * event | `Left of event | `Right of event
                 ] -> unit) ->
              unit
            val filter : t -> f:(event -> bool) -> t
            val partition_tf : t -> f:(event -> bool) -> t * t
            val elements : t -> event list
            val min_elt : t -> event option
            val min_elt_exn : t -> event
            val max_elt : t -> event option
            val max_elt_exn : t -> event
            val choose : t -> event option
            val choose_exn : t -> event
            val split : t -> event -> t * event option * t
            val group_by : t -> equiv:(event -> event -> bool) -> t list
            val find_exn : t -> f:(event -> bool) -> event
            val nth : t -> interval -> event option
            val remove_index : t -> interval -> t
            val to_tree : t -> t
            val to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:event ->
              ?less_or_equal_to:event -> t -> event Base.Sequence.t
            val binary_search :
              t ->
              compare:(event -> 'key -> interval) ->
              [ `First_equal_to
              | `First_greater_than_or_equal_to
              | `First_strictly_greater_than
              | `Last_equal_to
              | `Last_less_than_or_equal_to
              | `Last_strictly_less_than ] -> 'key -> event option
            val binary_search_segmented :
              t ->
              segment_of:(event -> [ `Left | `Right ]) ->
              [ `First_on_right | `Last_on_left ] -> event option
            val merge_to_sequence :
              ?order:[ `Decreasing | `Increasing ] ->
              ?greater_or_equal_to:event ->
              ?less_or_equal_to:event ->
              t ->
              t ->
              (event, event) Base__Set_intf.Merge_to_sequence_element.t
              Base.Sequence.t
            val to_map :
              t ->
              f:(event -> 'data) ->
              (event, 'data, Elt.comparator_witness) Base.Map.t
            val quickcheck_observer :
              event Core_kernel.Quickcheck.Observer.t ->
              t Core_kernel.Quickcheck.Observer.t
            val quickcheck_shrinker :
              event Core_kernel.Quickcheck.Shrinker.t ->
              t Core_kernel.Quickcheck.Shrinker.t
            val empty : t
            val singleton : event -> t
            val union_list : t list -> t
            val of_list : event list -> t
            val of_array : event array -> t
            val of_sorted_array : event array -> t Base.Or_error.t
            val of_sorted_array_unchecked : event array -> t
            val of_increasing_iterator_unchecked :
              len:interval -> f:(interval -> event) -> t
            val stable_dedup_list : event list -> event list
            val map :
              ('a, 'b) Core_kernel.Set_intf.Tree.t -> f:('a -> event) -> t
            val filter_map :
              ('a, 'b) Core_kernel.Set_intf.Tree.t ->
              f:('a -> event option) -> t
            val of_tree : t -> t
            val of_hash_set : event Core_kernel.Hash_set.t -> t
            val of_hashtbl_keys : (event, 'a) Core_kernel.Hashtbl.t -> t
            val of_map_keys :
              (event, 'a, Elt.comparator_witness) Base.Map.t -> t
            val quickcheck_generator :
              event Core_kernel.Quickcheck.Generator.t ->
              t Core_kernel.Quickcheck.Generator.t
            module Provide_of_sexp :
              functor
                (Elt : sig
                         val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> event
                       end)
                -> sig val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t end
            val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t
            val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t
          end
        type t = (event, Elt.comparator_witness) Base.Set.t
        val compare : t -> t -> interval
        type named = (event, Elt.comparator_witness) Base.Set.Named.t
        val length : t -> interval
        val is_empty : t -> bool
        val iter : t -> f:(event -> unit) -> unit
        val fold :
          t -> init:'accum -> f:('accum -> event -> 'accum) -> 'accum
        val fold_result :
          t ->
          init:'accum ->
          f:('accum -> event -> ('accum, 'e) Base.Result.t) ->
          ('accum, 'e) Base.Result.t
        val exists : t -> f:(event -> bool) -> bool
        val for_all : t -> f:(event -> bool) -> bool
        val count : t -> f:(event -> bool) -> interval
        val sum :
          (module Base__Container_intf.Summable with type t = 'sum) ->
          t -> f:(event -> 'sum) -> 'sum
        val find : t -> f:(event -> bool) -> event option
        val find_map : t -> f:(event -> 'a option) -> 'a option
        val to_list : t -> event list
        val to_array : t -> event array
        val invariants : t -> bool
        val mem : t -> event -> bool
        val add : t -> event -> t
        val remove : t -> event -> t
        val union : t -> t -> t
        val inter : t -> t -> t
        val diff : t -> t -> t
        val symmetric_diff :
          t -> t -> (event, event) Base.Either.t Base.Sequence.t
        val compare_direct : t -> t -> interval
        val equal : t -> t -> bool
        val is_subset : t -> of_:t -> bool
        val are_disjoint : t -> t -> bool
        module Named :
          sig
            val is_subset : named -> of_:named -> unit Base.Or_error.t
            val equal : named -> named -> unit Base.Or_error.t
          end
        val fold_until :
          t ->
          init:'b ->
          f:('b -> event -> ('b, 'final) Base__Set_intf.Continue_or_stop.t) ->
          finish:('b -> 'final) -> 'final
        val fold_right : t -> init:'b -> f:(event -> 'b -> 'b) -> 'b
        val iter2 :
          t ->
          t ->
          f:([ `Both of event * event | `Left of event | `Right of event ] ->
             unit) ->
          unit
        val filter : t -> f:(event -> bool) -> t
        val partition_tf : t -> f:(event -> bool) -> t * t
        val elements : t -> event list
        val min_elt : t -> event option
        val min_elt_exn : t -> event
        val max_elt : t -> event option
        val max_elt_exn : t -> event
        val choose : t -> event option
        val choose_exn : t -> event
        val split : t -> event -> t * event option * t
        val group_by : t -> equiv:(event -> event -> bool) -> t list
        val find_exn : t -> f:(event -> bool) -> event
        val nth : t -> interval -> event option
        val remove_index : t -> interval -> t
        val to_tree : t -> Tree.t
        val to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:event ->
          ?less_or_equal_to:event -> t -> event Base.Sequence.t
        val binary_search :
          t ->
          compare:(event -> 'key -> interval) ->
          [ `First_equal_to
          | `First_greater_than_or_equal_to
          | `First_strictly_greater_than
          | `Last_equal_to
          | `Last_less_than_or_equal_to
          | `Last_strictly_less_than ] -> 'key -> event option
        val binary_search_segmented :
          t ->
          segment_of:(event -> [ `Left | `Right ]) ->
          [ `First_on_right | `Last_on_left ] -> event option
        val merge_to_sequence :
          ?order:[ `Decreasing | `Increasing ] ->
          ?greater_or_equal_to:event ->
          ?less_or_equal_to:event ->
          t ->
          t ->
          (event, event) Base__Set_intf.Merge_to_sequence_element.t
          Base.Sequence.t
        val to_map :
          t ->
          f:(event -> 'data) ->
          (event, 'data, Elt.comparator_witness) Base.Map.t
        val quickcheck_observer :
          event Core_kernel.Quickcheck.Observer.t ->
          t Core_kernel.Quickcheck.Observer.t
        val quickcheck_shrinker :
          event Core_kernel.Quickcheck.Shrinker.t ->
          t Core_kernel.Quickcheck.Shrinker.t
        val empty : t
        val singleton : event -> t
        val union_list : t list -> t
        val of_list : event list -> t
        val of_array : event array -> t
        val of_sorted_array : event array -> t Base.Or_error.t
        val of_sorted_array_unchecked : event array -> t
        val of_increasing_iterator_unchecked :
          len:interval -> f:(interval -> event) -> t
        val stable_dedup_list : event list -> event list
        val map : ('a, 'b) Base.Set.t -> f:('a -> event) -> t
        val filter_map : ('a, 'b) Base.Set.t -> f:('a -> event option) -> t
        val of_tree : Tree.t -> t
        val of_hash_set : event Core_kernel.Hash_set.t -> t
        val of_hashtbl_keys : (event, 'a) Core_kernel.Hashtbl.t -> t
        val of_map_keys : (event, 'a, Elt.comparator_witness) Base.Map.t -> t
        val quickcheck_generator :
          event Core_kernel.Quickcheck.Generator.t ->
          t Core_kernel.Quickcheck.Generator.t
        module Provide_of_sexp :
          functor
            (Elt : sig val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> event end)
            -> sig val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t end
        module Provide_bin_io :
          functor
            (Elt : sig
                     val bin_size_t : event Bin_prot.Size.sizer
                     val bin_write_t : event Bin_prot.Write.writer
                     val bin_read_t : event Bin_prot.Read.reader
                     val __bin_read_t__ :
                       (interval -> event) Bin_prot.Read.reader
                     val bin_shape_t : Bin_prot.Shape.t
                     val bin_writer_t : event Bin_prot.Type_class.writer
                     val bin_reader_t : event Bin_prot.Type_class.reader
                     val bin_t : event Bin_prot.Type_class.t
                   end)
            ->
            sig
              val bin_size_t : t Bin_prot.Size.sizer
              val bin_write_t : t Bin_prot.Write.writer
              val bin_read_t : t Bin_prot.Read.reader
              val __bin_read_t__ : (interval -> t) Bin_prot.Read.reader
              val bin_shape_t : Bin_prot.Shape.t
              val bin_writer_t : t Bin_prot.Type_class.writer
              val bin_reader_t : t Bin_prot.Type_class.reader
              val bin_t : t Bin_prot.Type_class.t
            end
        module Provide_hash :
          functor
            (Elt : sig
                     val hash_fold_t :
                       Base.Hash.state -> event -> Base.Hash.state
                   end)
            ->
            sig
              val hash_fold_t :
                Ppx_hash_lib.Std.Hash.state ->
                t -> Ppx_hash_lib.Std.Hash.state
              val hash : t -> Ppx_hash_lib.Std.Hash.hash_value
            end
        val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t
        val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t
      end
    module Elt = M.Elt
    module Tree = M.Tree
    type t = (event, Elt.comparator_witness) Base.Set.t
    val compare : t -> t -> interval
    type named = (event, Elt.comparator_witness) Base.Set.Named.t
    val length : t -> interval
    val is_empty : t -> bool
    val iter : t -> f:(event -> unit) -> unit
    val fold : t -> init:'accum -> f:('accum -> event -> 'accum) -> 'accum
    val fold_result :
      t ->
      init:'accum ->
      f:('accum -> event -> ('accum, 'e) Base.Result.t) ->
      ('accum, 'e) Base.Result.t
    val exists : t -> f:(event -> bool) -> bool
    val for_all : t -> f:(event -> bool) -> bool
    val count : t -> f:(event -> bool) -> interval
    val sum :
      (module Base__Container_intf.Summable with type t = 'sum) ->
      t -> f:(event -> 'sum) -> 'sum
    val find : t -> f:(event -> bool) -> event option
    val find_map : t -> f:(event -> 'a option) -> 'a option
    val to_list : t -> event list
    val to_array : t -> event array
    val invariants : t -> bool
    val mem : t -> event -> bool
    val add : t -> event -> t
    val remove : t -> event -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val symmetric_diff :
      t -> t -> (event, event) Base.Either.t Base.Sequence.t
    val compare_direct : t -> t -> interval
    val equal : t -> t -> bool
    val is_subset : t -> of_:t -> bool
    val are_disjoint : t -> t -> bool
    module Named = M.Named
    val fold_until :
      t ->
      init:'b ->
      f:('b -> event -> ('b, 'final) Base__Set_intf.Continue_or_stop.t) ->
      finish:('b -> 'final) -> 'final
    val fold_right : t -> init:'b -> f:(event -> 'b -> 'b) -> 'b
    val iter2 :
      t ->
      t ->
      f:([ `Both of event * event | `Left of event | `Right of event ] ->
         unit) ->
      unit
    val filter : t -> f:(event -> bool) -> t
    val partition_tf : t -> f:(event -> bool) -> t * t
    val elements : t -> event list
    val min_elt : t -> event option
    val min_elt_exn : t -> event
    val max_elt : t -> event option
    val max_elt_exn : t -> event
    val choose : t -> event option
    val choose_exn : t -> event
    val split : t -> event -> t * event option * t
    val group_by : t -> equiv:(event -> event -> bool) -> t list
    val find_exn : t -> f:(event -> bool) -> event
    val nth : t -> interval -> event option
    val remove_index : t -> interval -> t
    val to_tree : t -> Tree.t
    val to_sequence :
      ?order:[ `Decreasing | `Increasing ] ->
      ?greater_or_equal_to:event ->
      ?less_or_equal_to:event -> t -> event Base.Sequence.t
    val binary_search :
      t ->
      compare:(event -> 'key -> interval) ->
      [ `First_equal_to
      | `First_greater_than_or_equal_to
      | `First_strictly_greater_than
      | `Last_equal_to
      | `Last_less_than_or_equal_to
      | `Last_strictly_less_than ] -> 'key -> event option
    val binary_search_segmented :
      t ->
      segment_of:(event -> [ `Left | `Right ]) ->
      [ `First_on_right | `Last_on_left ] -> event option
    val merge_to_sequence :
      ?order:[ `Decreasing | `Increasing ] ->
      ?greater_or_equal_to:event ->
      ?less_or_equal_to:event ->
      t ->
      t ->
      (event, event) Base__Set_intf.Merge_to_sequence_element.t
      Base.Sequence.t
    val to_map :
      t ->
      f:(event -> 'data) -> (event, 'data, Elt.comparator_witness) Base.Map.t
    val quickcheck_observer :
      event Core_kernel.Quickcheck.Observer.t ->
      t Core_kernel.Quickcheck.Observer.t
    val quickcheck_shrinker :
      event Core_kernel.Quickcheck.Shrinker.t ->
      t Core_kernel.Quickcheck.Shrinker.t
    val empty : t
    val singleton : event -> t
    val union_list : t list -> t
    val of_list : event list -> t
    val of_array : event array -> t
    val of_sorted_array : event array -> t Base.Or_error.t
    val of_sorted_array_unchecked : event array -> t
    val of_increasing_iterator_unchecked :
      len:interval -> f:(interval -> event) -> t
    val stable_dedup_list : event list -> event list
    val map : ('a, 'b) Base.Set.t -> f:('a -> event) -> t
    val filter_map : ('a, 'b) Base.Set.t -> f:('a -> event option) -> t
    val of_tree : Tree.t -> t
    val of_hash_set : event Core_kernel.Hash_set.t -> t
    val of_hashtbl_keys : (event, 'a) Core_kernel.Hashtbl.t -> t
    val of_map_keys : (event, 'a, Elt.comparator_witness) Base.Map.t -> t
    val quickcheck_generator :
      event Core_kernel.Quickcheck.Generator.t ->
      t Core_kernel.Quickcheck.Generator.t
    module Provide_of_sexp = M.Provide_of_sexp
    module Provide_bin_io = M.Provide_bin_io
    module Provide_hash = M.Provide_hash
    val t_of_sexp : Ppx_sexp_conv_lib.Sexp.t -> t
    val sexp_of_t : t -> Ppx_sexp_conv_lib.Sexp.t
    val to_string : ?sep:string -> M.t -> string
    val permutations : M.t -> event list list
  end
module ExEventSet = EventSet
type 'a will_list = (Common.person * 'a) list
val will_list_of_sexp :
  (Ppx_sexp_conv_lib.Sexp.t -> 'a) ->
  Ppx_sexp_conv_lib.Sexp.t -> 'a will_list
val sexp_of_will_list :
  ('a -> Ppx_sexp_conv_lib.Sexp.t) ->
  'a will_list -> Ppx_sexp_conv_lib.Sexp.t
module Wills :
  sig
    type 'a t = 'a will_list
    val t_of_sexp :
      (Ppx_sexp_conv_lib.Sexp.t -> 'a) -> Ppx_sexp_conv_lib.Sexp.t -> 'a t
    val sexp_of_t :
      ('a -> Ppx_sexp_conv_lib.Sexp.t) -> 'a t -> Ppx_sexp_conv_lib.Sexp.t
    val add_will :
      'a -> 'b -> ('a, 'b) Base.List.Assoc.t -> ('a, 'b) Base.List.Assoc.t
    val will_of : 'a -> ('a, 'b) Base.List.Assoc.t -> 'b option
  end
